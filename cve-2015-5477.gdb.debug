GNU gdb (GDB) 7.8.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-pc-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./named...done.
(gdb) set detach-on-fork off 
(gdb) set follow-fork-mode child 
(gdb) b * dns_
Display all 2100 possibilities? (y or n)
(gdb) b * dns_message_fi
dns_message_find       dns_message_findname   dns_message_findtype   dns_message_firstname  
(gdb) b *dns_tkey_processquery
Breakpoint 1 at 0x8200bab: file tkey.c, line 618.
(gdb) r
Starting program: /home/Jioun_dai/security/vuln/bind9.10/sbin/named 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/i386-linux-gnu/libthread_db.so.1".
[New process 2927]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/i386-linux-gnu/libthread_db.so.1".
[New Thread 0xb78bbb40 (LWP 2928)]
[New Thread 0xb70bab40 (LWP 2929)]
[New Thread 0xb68b9b40 (LWP 2930)]
[New Thread 0xb60b8b40 (LWP 2931)]
[Switching to Thread 0xb78bbb40 (LWP 2928)]

Breakpoint 1, dns_tkey_processquery (msg=0x400, tctx=0x0, ring=0x0) at tkey.c:618
618 {
(gdb) n
619     isc_result_t result = ISC_R_SUCCESS;
(gdb) 
621     isc_boolean_t freetkeyin = ISC_FALSE;
(gdb) 
630     REQUIRE(msg != NULL);
(gdb) 
631     REQUIRE(tctx != NULL);
(gdb) 
632     REQUIRE(ring != NULL);
(gdb) 
634     ISC_LIST_INIT(namelist);
(gdb) 
639     result = dns_message_firstname(msg, DNS_SECTION_QUESTION);
(gdb) 
640     if (result != ISC_R_SUCCESS)
(gdb) print resu
result                 result.h               resulttable            resume_dslookup        resume_signingwithkey
result.c               resultclass.h          resume_addnsec3chain   resume_iteration       
(gdb) print result
$1 = 0
(gdb) n
643     qname = NULL;
(gdb) 
644     dns_message_currentname(msg, DNS_SECTION_QUESTION, &qname);
(gdb) 
649     tkeyset = NULL;
(gdb) print qname
$2 = (dns_name_t *) 0xb5643008
(gdb) print qname->ndata
$3 = (unsigned char *) 0xb563f02c "\003foo\003bar"
(gdb) n
650     name = NULL;
(gdb) 
651     result = dns_message_findname(msg, DNS_SECTION_ADDITIONAL, qname,
(gdb) s
dns_message_findname (msg=0xb563d008, section=3, target=0xb5643008, type=249, covers=0, name=0xb78ba3d0, rdataset=0xb78ba3d4)
    at message.c:2331
2331        REQUIRE(msg != NULL);
(gdb) p name
$4 = (dns_name_t **) 0xb78ba3d0
(gdb) p name->
attributes  buffer      labels      length      link        list        magic       ndata       offsets     
(gdb) p name->labels 
Cannot access memory at address 0xc
(gdb) n
2332        REQUIRE(VALID_SECTION(section));
(gdb) p section
$5 = 3
(gdb) n
2333        REQUIRE(target != NULL);
(gdb) p target 
$6 = (dns_name_t *) 0xb5643008
(gdb) p target->labels 
$7 = 3
(gdb) p target->ndata 
$8 = (unsigned char *) 0xb563f02c "\003foo\003bar"
(gdb) n
2334        if (name != NULL)
(gdb) p name
$9 = (dns_name_t **) 0xb78ba3d0
(gdb) n
2335            REQUIRE(*name == NULL);
(gdb) p *name
$10 = (dns_name_t *) 0x0
(gdb) n
2336        if (type == dns_rdatatype_any) {
(gdb) p type
$11 = 249
(gdb) n
2339            if (rdataset != NULL)
(gdb) p rdataset
$12 = (dns_rdataset_t **) 0xb78ba3d4
(gdb) n
2340                REQUIRE(*rdataset == NULL);
(gdb) 
2343        result = findname(&foundname, target,
(gdb) s
findname (foundname=0xb78ba378, target=0xb5643008, section=0xb563d048) at message.c:834
834     for (curr = ISC_LIST_TAIL(*section);
(gdb) n
837         if (dns_name_equal(curr, target)) {
(gdb) p curr
$13 = (dns_name_t *) 0xb5643038
(gdb) p curr->ndata 
$14 = (unsigned char *) 0xb563f035 "\003foo\003bar"
(gdb) p curr->labels 
$15 = 3
(gdb) p *curr
$16 = {magic = 1145983854, ndata = 0xb563f035 "\003foo\003bar", length = 9, labels = 3, attributes = 1, offsets = 0xb5644118 "", 
  buffer = 0x0, link = {prev = 0x0, next = 0x0}, list = {head = 0xb5646050, tail = 0xb5646050}}
(gdb) n
838             if (foundname != NULL)
(gdb) p foundname 
$17 = (dns_name_t **) 0xb78ba378
(gdb) n
839                 *foundname = curr;
(gdb) n
840             return (ISC_R_SUCCESS);
(gdb) 
845 }
(gdb) 
dns_message_findname (msg=0xb563d008, section=3, target=0xb5643008, type=249, covers=0, name=0xb78ba3d0, rdataset=0xb78ba3d4)
    at message.c:2346
2346        if (result == ISC_R_NOTFOUND)
(gdb) 
2348        else if (result != ISC_R_SUCCESS)
(gdb) 
2351        if (name != NULL)
(gdb) p name
$18 = (dns_name_t **) 0xb78ba3d0
(gdb) n
2352            *name = foundname;
(gdb) 
2357        if (type == dns_rdatatype_any)
(gdb) p *name
$19 = (dns_name_t *) 0xb5643038
(gdb) n
2360        result = dns_message_findtype(foundname, type, covers, rdataset);
(gdb) s
dns_message_findtype (name=0xb5643038, type=249, covers=0, rdataset=0xb78ba3d4) at message.c:878
878     REQUIRE(name != NULL);
(gdb) 
879     if (rdataset != NULL) {
(gdb) 
880         REQUIRE(*rdataset == NULL);
(gdb) 
883     for (curr = ISC_LIST_TAIL(name->list);
(gdb) p name->list 
$20 = {head = 0xb5646050, tail = 0xb5646050}
(gdb) n
886         if (curr->type == type && curr->covers == covers) {
(gdb) p *curr
$21 = {magic = 1145983826, methods = 0x83a2880 <methods>, link = {prev = 0x0, next = 0x0}, rdclass = 255, type = 16, ttl = 0, 
  trust = 0, covers = 0, attributes = 0, count = 4294967295, resign = 0, private1 = 0xb56450c0, private2 = 0x0, private3 = 0x0, 
  privateuint4 = 0, private5 = 0x0, private6 = 0x0, private7 = 0x0}
(gdb) p type
$22 = 249
(gdb) n
885          curr = ISC_LIST_PREV(curr, link)) {
(gdb) n
883     for (curr = ISC_LIST_TAIL(name->list);
(gdb) p *curr
Cannot access memory at address 0x0
(gdb) n
893     return (ISC_R_NOTFOUND);
(gdb) 
894 }
(gdb) n
dns_message_findname (msg=0xb563d008, section=3, target=0xb5643008, type=249, covers=0, name=0xb78ba3d0, rdataset=0xb78ba3d4)
    at message.c:2361
2361        if (result == ISC_R_NOTFOUND)
(gdb) n
2362            return (DNS_R_NXRRSET);
(gdb) n
2365    }
(gdb) n
dns_tkey_processquery (msg=0xb563d008, tctx=0xb78be128, ring=0xb56840c0) at tkey.c:653
653     if (result != ISC_R_SUCCESS) {
(gdb) n
658         if (dns_message_findname(msg, DNS_SECTION_ANSWER, qname,
(gdb) s
dns_message_findname (msg=0xb563d008, section=1, target=0xb5643008, type=249, covers=0, name=0xb78ba3d0, rdataset=0xb78ba3d4)
    at message.c:2331
2331        REQUIRE(msg != NULL);
(gdb) p name
$23 = (dns_name_t **) 0xb78ba3d0
(gdb) p *name
$24 = (dns_name_t *) 0xb5643038
(gdb) n
2332        REQUIRE(VALID_SECTION(section));
(gdb) 
2333        REQUIRE(target != NULL);
(gdb) 
2334        if (name != NULL)
(gdb) 
2335            REQUIRE(*name == NULL);
(gdb) 

Program received signal SIGABRT, Aborted.
0xb7fdd424 in ?? ()
